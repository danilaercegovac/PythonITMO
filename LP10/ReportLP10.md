# Лабораторная работа №10  
**Тема:** Методы оптимизации вычисления кода с помощью потоков, процессов, Cython и отпускания GIL  
**Объект исследования:** численное интегрирование методом прямоугольников (left Riemann sum)  
**Среда:** Python (CPython), ThreadPoolExecutor / ProcessPoolExecutor, Cython, режим `nogil`

---

## 1. Цель работы

Цель лабораторной работы — исследовать и сравнить методы оптимизации вычислительного кода на примере численного интегрирования методом прямоугольников:

- реализовать базовую версию интегрирования на чистом Python;
- улучшить качество кода (документация, аннотации типов, тестирование);
- сравнить производительность вычислений при использовании:
  - потоков (ThreadPoolExecutor),
  - процессов (ProcessPoolExecutor),
  - Cython-оптимизации (типизация + C-level функции),
  - Cython с отпусканием GIL (`nogil`) для эффективного многопоточного выполнения CPU-bound задач;
- зафиксировать результаты замеров времени выполнения (timeit) и оформить их в отчёте.

---

## 2. Структура проекта

Ниже перечислены основные файлы проекта и их назначение:

- **`integrate_py.py`**  
  Базовая реализация `integrate()` на чистом Python (метод прямоугольников).  
  Содержит:
  - docstring по PEP 257 с `doctest`,
  - аннотации типов по PEP 484,
  - проверки входных параметров.

- **`test_integrate.py`**  
  Unit-тесты на `unittest`:
  - проверка известного интеграла,
  - проверка устойчивости/улучшения точности при увеличении `n_iter`.

- **`bench_iter1.py`**  
  Бенчмарк базовой Python-версии `integrate()` с помощью `timeit` для разных `n_iter`.

- **`integrate_threads.py`**  
  Реализация `integrate_threaded()` — распараллеливание вычислений по подотрезкам через `ThreadPoolExecutor`.  
  Используется для сравнения эффективности потоков на CPU-bound задаче под GIL.

- **`integrate_processes.py`**  
  Реализация `integrate_processed()` — распараллеливание по процессам через `ProcessPoolExecutor`.  
  Обходит ограничения GIL, обычно даёт ускорение на многоядерных CPU.

- **`bench_iter2_3.py`**  
  Бенчмарк потоковой и процессной версии (2, 4, 6, 8 workers) + сравнение с baseline.

- **`cyintegrate.pyx`**  
  Cython-реализация интегрирования:
  - `integrate_cy_generic()` — принимает Python-callable (ускорение ограничено),
  - `integrate_cy_sin()` / `integrate_cy_cos()` — выполняются полностью на C-уровне (максимальная оптимизация).
  Включает директивы оптимизации: `boundscheck=False`, `wraparound=False`, `cdivision=True`, типизацию `double`.

- **`setup.py`**  
  Сборка расширения `cyintegrate` через `cythonize`, включено `annotate=True` для HTML-отчёта о взаимодействии с C-API.

- **`bench_iter4.py`**  
  Бенчмарк Python vs Cython-generic vs Cython (pure C math).

- **`cyintegrate_nogil.pyx`**  
  Cython-реализация интегрирования sin(x) с `nogil`:
  - основной цикл выполняется без GIL,
  - не используется Python-callable, только C `sin()`.

- **`setup_nogil.py`**  
  Сборка модуля `cyintegrate_nogil` (`annotate=True` также включён).

- **`integrate_threads_nogil.py`**  
  Python-обёртка `integrate_sin_threaded_nogil()`:
  - разбивает интервал,
  - запускает `ThreadPoolExecutor`,
  - каждый поток вызывает Cython `integrate_sin_nogil()` (внутри `nogil`),
  - суммирует результат (реальное ускорение потоками).

- **`bench_iter5.py`**  
  Финальный бенчмарк: сравнение
  - threads (GIL),
  - processes,
  - threads + noGIL (Cython).

- **`screenshots/`**  
  Папка с пруфами результатов (логи/таблицы/скриншоты):
  - `success_run_test_integrate.png` — успешный прогон unit-тестов,
  - `doctest_integrate_py.txt` — вывод doctest,
  - `table_bench_iter1.png` — таблица замеров итерации 1,
  - `table_bench_iter2_3.png` — таблица замеров потоков и процессов,
  - `table_bench_iter4.png` — таблица замеров Cython,
  - `table_bench_iter5.png` — таблица замеров noGIL + сравнение.

---

## 3. Описание реализации

Реализована базовая функция численного интегрирования методом прямоугольников на чистом Python и использована как baseline для сравнения производительности.

К функции добавлены docstring по PEP 257 с примерами `doctest`, аннотации типов по PEP 484, а также unit-тесты на `unittest` для проверки корректности и устойчивости к изменению `n_iter`.

Выполнены замеры времени выполнения baseline версии с помощью `timeit` для разных значений `n_iter` и результаты сохранены в виде таблицы.

Реализована параллельная версия на потоках (`ThreadPoolExecutor`) с разбиением интервала на подотрезки; по результатам замеров ускорение ограничено GIL.

Реализована параллельная версия на процессах (`ProcessPoolExecutor`), обеспечивающая реальное распараллеливание CPU-bound вычислений и ускорение по сравнению с потоками.

Интегратор переписан на Cython: сделана generic-версия с Python callback (ограниченное ускорение) и специализированная версия под `sin/cos` с вычислениями на C-уровне (максимальное ускорение). Для анализа взаимодействия с Python C-API использован `annotate=True` и сгенерирован HTML-отчёт.

Реализована версия Cython с отпусканием GIL (`nogil`) и потоковая обёртка, где каждый поток выполняет вычисления в C без GIL, что даёт реальную параллельность. Замеры для всех итераций зафиксированы и сохранены в папке `screenshots/`.



---

## 4. Выводы

### 4.1 Какие проблемы возникли при реализации

1. **Ожидание ускорения от потоков в CPython для CPU-bound задач**  
   Мне казалось, что `ThreadPoolExecutor` должен ускорить вычисления, но из-за GIL ускорения нет

2. **Попытка использовать `nogil` вместе с Python-объектами**  
   Оказалось, внутри `nogil` нельзя обращаться к Python API

---

### 4.2 Что нового узнал

- Как использовать `timeit` для воспроизводимых замеров производительности.
- Почему **многопоточность в CPython не ускоряет CPU-bound код** и что такое **GIL**.
- Почему **процессы** дают реальное ускорение и какие ограничения у multiprocessing (pickle).
- Как устроена оптимизация через **Cython**: типизация переменных, отключение проверок, использование C math.
- Как работать с `annotate=True` и читать HTML-отчёт для поиска мест взаимодействия с Python C-API.
